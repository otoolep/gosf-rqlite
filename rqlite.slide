rqlite
Replicating SQLite using Raft consensus

Philip O'Toole
GoSF April 20th 2016

http://www.philipotoole.com/
@general_order24

* About me

- Director of Data Platform Engineering at Percolate.
- Previously a full-time core developer with InfluxDB.
- Led the team that built Loggly's 2nd generation indexing and search platform.
- Big fan of Go, databases, and distributed systems.

* About rqlite

rqlite is a distributed system, which replicates a SQLite database using the Raft consensus protocol.

You can find the source at [[https://github.com/otoolep/rqlite]].

The current release is v2.2.0.

* Why?

* Why replicate SQLite?

- Rock solid relational database, within a single C soure file.
- With replication, you get reliability.
- Easy installation and deployment, thanks to Go.
- Lightweight operation.

* What is Raft?

* Raft is a distributed consensus protocol.

Such protocols are used to ensure multiple different nodes -- servers -- always agree on a given set of values.

It allows us to build a cluster of servers, such that for a quorum of servers within the cluster, each of those servers has the same state.

Within rqlite that state is a SQLite database.

* rqlite architecture

* A rqlite node

                 ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐    ┌ ─ ─ ─ ─ ┐
                             Clients                   Other
                 └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘    │  Nodes  │
                                │                    ─ ─ ─ ─ ─
                                │                        ▲
                                │                        │
                                │                        │
                                ▼                        ▼
                 ┌─────────────────────────────┐ ┌───────────────┐
                 │            HTTP             │ │      TCP      │
                 └─────────────────────────────┘ └───────────────┘
                 ┌───────────────────────────────────────────────┐
                 │             Raft (hashicorp/raft)             │
                 └───────────────────────────────────────────────┘
                 ┌───────────────────────────────────────────────┐
                 │               matt-n/go-sqlite3               │
                 └───────────────────────────────────────────────┘
                 ┌───────────────────────────────────────────────┐
                 │                   sqlite3.c                   │
                 └───────────────────────────────────────────────┘

All repositories hosted on Github

* rqlite clusters

rqlite clusters are most practical when 3, 5, or 7 nodes in size.

Even numbers don't get you anything, and larger than 7 becomes unwieldy.

rqlite is not suitable for replicating massive clusters, such as all the SQLite databases on a smartphone network.

* Hashicorp Raft

Raft implementation from Hashicorp, available at [[https://github.com/hashicorp/raft]]

Used by Consul, Nomad, and InfluxDB.

Another well known Raft implementation has been written by CoreOS, available at [[https://github.com/coreos/etcd/tree/master/raft]]

* Integrating with Hashicorp Raft

Integrating with the Raft consensus module involves implementing five key functions.

    Apply(l *raft.Log) interface{}       // Apply a committed entry to the state machine

    Snapshot() (raft.FSMSnapshot, error) // Returns a snapshot of the state machine

    Restore(rc io.ReadCloser) error      // Create state machine from snapshot

    Persist(sink raft.SnapshotSink)      // Write snapshot to persistent storage

    Release()                            // Snapshot release. Usually a no-op

A reference use of Hashicorp's Raft implementation is available at [[https://github.com/otoolep/hraftd]]

* Demo

* Lessons learned

* "Plan to throw one away. You will, anyhow."

rqlite v1.0 suffered from many shortcomings.

- Poor API.
- Used the generic Go SQL interfaces.
- Non-idiomatic Go code.
- go-raft as the consensus module, which was not really maintained.

But v1.0 was still used!

* rqlite v2.2.0

- Idiomatic Go code.
- Much better API, thanks to experience with InfluxDB.
- Limited use of 3rd party libraries.
- Good use of interfaces, which allows better testing.
- Direct use of the Go SQLite package.

* Better code means better features

- Read consistency levels: _strong_, _weak_, and _none_.
- Hot backups.
- In-memory database support.
- User-level permissioning.

There is now a Python driver available at [[https://github.com/zmedico/pyrqlite]]

* Next steps

rqlite is software, and software is never finished.

- Proper dependency management.
- A fully-featured CLI.
- Leader redirection.

* What rqlite can do

With it you've got a lightweight and reliable distributed store for relational data.

You could use rqlite as part of a larger system, as a central store for some critical relational data, without having to run a heavier solution like MySQL.

rqlite might also be an effective way to provide a small number of SQLite read-replicas.

* References

- [[https://github.com/otoolep/rqlite]]
- [[https://github.com/hashicorp/raft]]
- [[https://github.com/mattn/go-sqlite3]]
- [[https://github.com/otoolep/hraftd]]
- [[https://github.com/zmedico/pyrqlite]]
- [[https://github.com/goraft/raft]]
- [[https://raft.github.io/]]
- [[http://thesecretlivesofdata.com/raft/]]
